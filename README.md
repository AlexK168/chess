# **1. Постановки задачи**
**Цель** : применение теоретических знаний и выработка практических навыков разработки архитектуры приложения, работы с базами данных, использования шаблонов проектирования в процессе разработки приложения «Шахматы».

Предлагается реализовать приложение, которое:
1. предоставляет возможность сыграть партию в шахматы;
2. обеспечивает проверку допустимости сделанного хода в соответствии со стандартными правилами шахмат;
3. проверяет статус игры после каждого хода: шах, мат, пат;
4. позволяет сохранить игру в локальную базу данных;
5. записывает игру в соответствии с шахматной нотацией;
6. позволяет воспроизвести сохранённую игру.

# **2. Выбор инструментов**

**1. Qt** – кроссплатформенный фреймворк для разработки программного обеспечения на языке программирования C++.

### 2.1. Основные преимущества Qt

1. Qt написан на языке C++ и предполагает написание кода на С++, а значит проблем со скоростью работы не будет.
2. В Qt на уровне базового класса реализован паттерн Наблюдатель, а значит будет очень просто организовывать взаимодействие объектов.
3. Qt распространяется по трём лицензиям – для некоммерческих целей можно использовать бесплатные лицензии.
4. Очень удобное API. Qt – полноценный фреймворк, имеющий широкий набор классов, подходящий для большинства задач разработчика ПО.
5. Qt развивается с 1996 года, и за это время успел собрать очень широкое комьюнити, которое поможет, если возникнут проблемы.
6. Qt – кроссплатформенный фреймворк, а значит, при желании, перенести приложение на любую из популярных операционных систем не составит труда.
7. Очень хорошая документация.

**2. Qt  Creator** — кроссплатформенная свободная IDE для разработки на С, С++ и QML. Разработана для работы с фреймворком Qt. Включает в себя графический интерфейс отладчика и визуальные средства разработки интерфейса с использованием QtWidgets.

### 2.2. Основные преимущества IDE-среды Qt Creator

1. Qt Creator поддерживает систему сборки qmake.
2. IDE нативно поддерживает систему контроля версии Git.
3. Удобная навигация по коду и достаточно большое количество инструментов, упрощающий написание кода и ускоряющих разработку: автодополнения, автогенерации и т.д.
4. В отладчике реализовано отображение содержимого контейнеров, таких как QString, std::map и прочих.
5. Визуальные средства разработки интерфейса.
6. Документация Qt открывается прямо в IDE.

**3. SQLite** — компактная встраиваемая СУБД.

### 2.3. Основные преимущества  SQLite

1. SQLite не требует отдельного процесса сервера или системы для работы.
2. QLite поставляется с нулевой конфигурацией, что означает отсутствие необходимости в настройке или администрировании.
3. Полная база данных SQLite хранится в одном кросс-платформенном диске.
4. SQLite очень маленький и легкий, менее 400KiB полностью сконфигурированный.
5. SQLite является автономным, что означает отсутствие внешних зависимостей.
6. SQLite написан на ANSI-C и предоставляет простой в использовании API.
7. SQLite доступен в UNIX (Linux, Mac OS-X, Android, iOS) и Windows (Win32, WinCE, WinRT).

#
# **3. Краткие теоретические сведения**

### 3.1. Шахматная нотация

Шахматная нотация – система условных обозначений, применяемых для записи шахматной партии или положения фигур на шахматной доске.

Мы будем использовать следующую нотацию: поле указывается значениями \*горизонтальная координата\*\*вертикальная координата\*, например, b5. Фигуры: пешка — P, конь — N, слон — B, ладья — R, ферзь — Q, король — K. Ход обозначается, например, так: Ba1-c3, что значит «слон походил с поля a1 на поле c3», или так: Ba1xc3, что значит «слон походил с поля a1 на поле c3, побив фигуру». Большая и малая рокировки обозначаются 0-0-0 и 0-0 соответственно. При взятии на проходе за клеткой, куда передвинулась пешка, дописывается e.p. (en passand), например, «Pb5-a6e.p.». Если пешка совершила превращение, то в конце записи добавляется «=Q», «=R», «=N» или «=B», например, «Pb7xa8=Q». Если в результате хода противнику был объявлен шах, двойной шах, мат или пат, то в конце дописывается «+», «++», «#», «=» соответственно.

### 3.2. Шаблоны

MVC, «Модель-Представление-Контроллер», – схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер – таким образом, что модификация каждого компонента может осуществляться независимо.

Наблюдатель – поведенческий шаблон проектирования. Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними. Этот шаблон представлен в Qt слотами и сигналами, доступными всем классам, наследуемым от QObject.

# **4. Разработка структуры приложения**

Для начала разработаем схемуотношений классов нашего будущего приложения:
![_рис. 1 – UML диаграмма классов_](https://github.com/foxfrikses/chess/raw/master/images/image1.png)

 Приложение будет реализовывать шаблон MVC. Как видим из схемы, роль контроллера будет выполнять класс Logic, роль модели – классы Board, BoardReplay и DBManager, роль представления – классы MainWindow, GameWindow, ReplayListGamesWindow, ReplayGameWindow, PromotionDialog, BoardWidget, SaveGameDialog и BoardReplayWidget. Разберёмся со всем по порядку.

Взаимодействовать между собой модель с представлением будут с помощью шаблона «Наблюдатель», то есть, на языке Qt, с помощью слотов и сигналов. Например, представление отправляет сигнал о выполнении пользователем какого-либо действия, модель ловит этот сигнал, обрабатывает, и отправляет свой сигнал с результатом, который ловит представление и отображает пользователю запрашиваемую информацию. Роль контроллера (класса Logic) тогда будет заключаться лишь в том, чтобы сконнектить слоты и сигналы представления и модели.

Разберёмся, что же будут из себя представлять классы слоя модели:

1. Board. Это основной класс нашего приложения. Тут будет вся логика самой игры: проверка допустимости хода, совершения хода, оповещения о совершении хода, определение статуса игры и прочее. То есть игра будет описана в этом классе.
2. BoardReplay. Это класс, который будет отвечать за то, чтобы воспроизвести записанную игру.
3. DBManager. Этот класс – интерфейс взаимодействия с базой данных.

Так как все классы должны взаимодействовать через слоты и сигналы, они все должны наследовать QObject:

![_рис. 2 – UML диаграмма классов_](https://github.com/foxfrikses/chess/raw/master/images/image2.png)

# **5. Разработка интерфейсов взаимодействия компонентов**

### 5.1. DBManager (интерфейс для сохранения партии)

```
signals:
    void stored();
public slots:
    void getLastMove(const std::pair<QString, Move>& move);
    void clear();
    void store(QString name);
```

Слот **getLastMove**(const std::pair<QString, Move>& move) добавляет в контейнер, где хванится информация о текущей партии, информацию о последнем сделанном ходе.

Слот **clear**() очищает информацию о партии.

Слот **store**(QString name) сохраняет партию в базу данных, давая ей название name, по которому позже эту партию можно будет просмотреть.

### 5.2. DBManager (интерфейс для воспроизведения партии)

```
signals:
    void sendGames(QStringList);
    void sendMoves(QVector<Move>);
    void sendMoves(QStringList);
public slots:
    void loadGame(QString name);
    void sendGames();
```

Слот **sendGames**() получает список сыгранных партий из базы данных и отправляет сигнал **sendGames**(QStringList), отправляя список сыгранных партий (этот сигнал позже сконнектится с представлением).

Слот **loadGame**(QString) получает из базы данных информацию о партии с названием name и отправляет два сигнала: **sendMoves**(QVector<Move>), который позже сконнектится со слотом класса BoardReplay, и **sendMoves**(QStringList), который передаёт список ходов, записанный в соответствии с шахматной нотацией: позже сконнектится со слотом представления.

### 5.3. Board

```
signals:
    void moved(int *const *const board, int status, bool turn);
    void promotion(bool turn);
    void message(QString msg);
    void sendLastMove(const std::pair<QString, Move>& move);
public slots:
    void move(const QPoint& from, const QPoint &to);
    void promotion(int man);
    void initBoard();
```

Слот **initBoard**() инициализирует доску: расставляет фигуры на места, устанавливает нейтральный статус игры и очередь белых ходить и отправляет сигнал **moved**(int\*const\*const board, int status, bool turn), содержащий в параметрах матрицу текущего положения фигур на доске, статус и очередь ходить. Этот сигнал позднее будет связан со слотом представления.

Слот **move**(const QPoint& from, const QPoint &to) принимает запрос на ход из точки from в точку to, обрабатывает его и поступает следующим образом: если ход допустим в соответствии с правилами шахмат, то, если это ход достижения пешкой поля превращения, отправляет сигнал void **promotion**(bool turn) для того, чтобы представление отправило в ответ (через слот **promotion**(int man)) значение фигуры, в которую должна превратиться пешка; если это не ход достижения пешкой поля превращения, формирует новую матрицу доски, устанавливает статус, очередь следующего хода, отправляет сигнал **moved**(int \*const \*const board, int status, bool turn) и сигнал **sendLastMove**sendLastMove(const std::pair<QString, Move>& move), который должен быть сконнекчен со слотом класса DBManager.

Слот **promotion**(int man), приняв значение фигуры, в которую игрок хочет превратить пешку, формирует новую матрицу доски, устанавливает статус, очередь следующего хода и отправляет сигналы **moved**(int \*const \*const board, int status, bool turn) и **sendLastMove**sendLastMove(const std::pair<QString, Move>& move).

### 5.4. BoardReplay

```
signals:
    void moved(int*const*const board, int status, bool turn);
public slots:
    void initBoard(QVector<Move> moves);
    void move(int nMove);
```

Слот **initBoard**(QVector<Move> moves) получает информацию о партии (сконнекчен с сигналом DBManager), отправляет сигнал **moved**(int \*const \*const board, int status, bool turn), аналогичный по цели сигналу с такой сигнатурой из Board, отправляя состояние доски до первого хода.

Слот **move**(int nMove) отправляет сигнал **moved**(int \*const \*const board, int status, bool turn), отправляя состояние доски после nMove-го хода.

# **6. Разработанное приложение**

Рассмотрим разработанное приложение.

При запуске приложения перед нами открывается главное меню – окно MainWindow:
![_рис. 3 – главное меню_](https://github.com/foxfrikses/chess/raw/master/images/image3.png)

В этом окне две кнопки: мы можем выбрать New game, чтобы сыграть партию, или Replay, чтобы воспроизвести партию. Давайте нажмем New game – перед нами откроется окно игры:

![_рис. 4 – окно игры_](https://github.com/foxfrikses/chess/raw/master/images/image4.png)

Что тут есть: слева - доска, на которой мы можем перемещать фигурки перетаскиванием мышью (если ход допустим, то новое положение фигурки установится), справа — две надписи (со статусом игры и очерёдностью хода) и три кнопки: Exit, чтобы вернуться в главное меню, Save Game, чтобы сохранить игру, и New game, чтобы начать новую партию без сохранения.

Сыграем партию и нажмём Save Game:

![_рис. 5 – окно игры_](https://github.com/foxfrikses/chess/raw/master/images/image5.png)

Перед нами появится диалоговое окно ввода названия игры:

![_рис. 6 – окно ввода названия игры_](https://github.com/foxfrikses/chess/raw/master/images/image6.png)

Введём название и нажмём Save. Окно закроется. В окне игры нажмём Exit, чтобы вернуться в меню. Теперь нажмём Replay. Откроется окно со списком ранее сохранённых игр:

![_рис. 7 – окно списка сохранённых игр_](https://github.com/foxfrikses/chess/raw/master/images/image7.png)

Нажмём на название только что сохранённой игры — откроется окно воспроизведения игры:

![_рис. 8 – окно воспроизведения игры_](https://github.com/foxfrikses/chess/raw/master/images/image8.png)

Здесь есть список ходов и кнопка Exit, возвращающая в главное меню. По нажатии на ход в этом списке отображается состояние доски на момент после совершения этого хода:

![_рис. 9 – окно воспроизведения игры_](https://github.com/foxfrikses/chess/raw/master/images/image9.png)

# 7. Варианты усовершенствования

Это приложение можно ещё очень много совершенствовать. Например:

1. Добавить возможность удаления, переименования игр.
2. Добавить возможность отменять ходы в процессе игры. А также возможность сдаться, предложить ничью.
3. Добавить возможность устанавливать время, выделенное на партию.
4. Добавить возможность сохранить партию, загрузить партию до какого-то момента, и продолжить играть с этого момента.
5. Добавить режим решения обучающих шахматных задач.
6. Усовершенствовать GUI.
7. Реализовать GUI для Android и iOS.
8. И прочее.

# Заключение

Результатом выполнения данной курсовой работы стало разработанное приложение «Шахматы», отвечающее всем поставленным задачам: предоставление возможности сыграть партию, проверка допустимости сделанного хода, проверка статуса игры после каждого хода, предоставление возможности сохранить игру и воспроизвести сохранённую игру.

Достаточно простой и интуитивно понятный интерфейс скрывает за собой сложную игровую логику, полностью соответствующую стандартным правилам шахмат. Приложение позволяет комфортно выполнять задачи, для решения которых оно разрабатывалось.
